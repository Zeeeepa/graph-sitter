"""
Task class for managing Codegen agent tasks.
"""

import time
from typing import Optional, Dict, Any, List
from datetime import datetime

from .exceptions import TaskError, APIError


class Task:
    """
    Represents a task executed by a Codegen agent.
    
    Tasks can be in various states: pending, running, completed, failed, cancelled.
    """
    
    def __init__(self, task_id: str, agent, initial_data: Dict[str, Any] = None):
        """
        Initialize a Task instance.
        
        Args:
            task_id: Unique identifier for the task
            agent: The Agent instance that created this task
            initial_data: Initial task data from the API
        """
        self.task_id = task_id
        self._agent = agent
        self._data = initial_data or {}
        self._last_updated = datetime.now()
    
    @property
    def status(self) -> str:
        """Get the current status of the task."""
        return self._data.get("status", "unknown")
    
    @property
    def result(self) -> Optional[str]:
        """Get the result of the task if completed."""
        return self._data.get("result")
    
    @property
    def error(self) -> Optional[str]:
        """Get the error message if the task failed."""
        return self._data.get("error")
    
    @property
    def progress(self) -> Optional[Dict[str, Any]]:
        """Get progress information for the task."""
        return self._data.get("progress")
    
    @property
    def created_at(self) -> Optional[str]:
        """Get the creation timestamp of the task."""
        return self._data.get("created_at")
    
    @property
    def updated_at(self) -> Optional[str]:
        """Get the last update timestamp of the task."""
        return self._data.get("updated_at")
    
    @property
    def prompt(self) -> Optional[str]:
        """Get the original prompt for the task."""
        return self._data.get("prompt")
    
    @property
    def metadata(self) -> Dict[str, Any]:
        """Get additional metadata for the task."""
        return self._data.get("metadata", {})
    
    @property
    def logs(self) -> List[Dict[str, Any]]:
        """Get execution logs for the task."""
        return self._data.get("logs", [])
    
    def refresh(self) -> "Task":
        """
        Refresh the task data from the API.
        
        Returns:
            Self for method chaining
            
        Raises:
            TaskError: If the task cannot be refreshed
        """
        try:
            updated_data = self._agent._get_task(self.task_id)
            self._data.update(updated_data)
            self._last_updated = datetime.now()
            return self
        except Exception as e:
            raise TaskError(f"Failed to refresh task {self.task_id}: {str(e)}")
    
    def wait_for_completion(self, timeout: int = 300, poll_interval: int = 5) -> "Task":
        """
        Wait for the task to complete.
        
        Args:
            timeout: Maximum time to wait in seconds (default: 300)
            poll_interval: Time between status checks in seconds (default: 5)
            
        Returns:
            Self for method chaining
            
        Raises:
            TaskError: If the task fails or times out
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            self.refresh()
            
            if self.status in ["completed", "failed", "cancelled"]:
                break
                
            time.sleep(poll_interval)
        else:
            raise TaskError(f"Task {self.task_id} did not complete within {timeout} seconds")
        
        if self.status == "failed":
            raise TaskError(f"Task {self.task_id} failed: {self.error}")
        elif self.status == "cancelled":
            raise TaskError(f"Task {self.task_id} was cancelled")
        
        return self
    
    def cancel(self) -> "Task":
        """
        Cancel the task if it's still running.
        
        Returns:
            Self for method chaining
            
        Raises:
            TaskError: If the task cannot be cancelled
        """
        try:
            self._agent._cancel_task(self.task_id)
            self.refresh()
            return self
        except Exception as e:
            raise TaskError(f"Failed to cancel task {self.task_id}: {str(e)}")
    
    def get_artifacts(self) -> List[Dict[str, Any]]:
        """
        Get artifacts generated by the task (e.g., created files, PRs, etc.).
        
        Returns:
            List of artifacts
            
        Raises:
            TaskError: If artifacts cannot be retrieved
        """
        try:
            return self._agent._get_task_artifacts(self.task_id)
        except Exception as e:
            raise TaskError(f"Failed to get artifacts for task {self.task_id}: {str(e)}")
    
    def __str__(self) -> str:
        """String representation of the task."""
        return f"Task(id={self.task_id}, status={self.status})"
    
    def __repr__(self) -> str:
        """Detailed string representation of the task."""
        return (f"Task(id={self.task_id}, status={self.status}, "
                f"created_at={self.created_at}, updated_at={self.updated_at})")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the task to a dictionary representation."""
        return {
            "task_id": self.task_id,
            "status": self.status,
            "result": self.result,
            "error": self.error,
            "progress": self.progress,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "prompt": self.prompt,
            "metadata": self.metadata,
            "logs": self.logs
        }

