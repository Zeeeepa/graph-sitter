"""
API endpoints for the Dashboard extension.

This module defines the FastAPI routes and endpoints for the dashboard system,
providing REST API access to project management, workflow orchestration, and
real-time updates functionality.
"""

import os
import logging
from typing import Any, Dict, List, Optional
from datetime import datetime

from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks
from fastapi.responses import JSONResponse

from .models import (
    Project, ProjectPin, WorkflowPlan, ProjectSettings,
    ProjectCreateRequest, ProjectPinRequest, WorkflowPlanRequest,
    SettingsUpdateRequest, EnvironmentVariablesRequest, DashboardResponse,
    ProjectStatus, FlowStatus
)
from .database import get_project_repository, get_workflow_repository, ProjectRepository, WorkflowRepository
from .github_integration import GitHubProjectManager
from .codegen_integration import CodegenPlanGenerator

logger = logging.getLogger(__name__)

# Create API router
router = APIRouter(prefix="/dashboard", tags=["dashboard"])


async def get_current_user() -> str:
    """Get current user ID. In a real implementation, this would extract from JWT token."""
    # TODO: Implement proper authentication
    return "default_user"


@router.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "timestamp": datetime.utcnow().isoformat()}


@router.get("/projects")
async def get_projects(
    user_id: str = Depends(get_current_user),
    project_repo: ProjectRepository = Depends(get_project_repository)
) -> DashboardResponse:
    """Get all projects pinned by the current user."""
    try:
        projects = await project_repo.get_projects_by_user(user_id)
        
        # Convert to dict format for JSON response
        projects_data = []
        for project in projects:
            projects_data.append({
                "id": project.id,
                "name": project.name,
                "full_name": project.full_name,
                "description": project.description,
                "url": project.url,
                "default_branch": project.default_branch,
                "language": project.language,
                "status": project.status.value,
                "created_at": project.created_at.isoformat(),
                "updated_at": project.updated_at.isoformat(),
                "metadata": project.metadata
            })
        
        return DashboardResponse(
            success=True,
            message=f"Retrieved {len(projects)} projects",
            data={"projects": projects_data}
        )
    except Exception as e:
        logger.error(f"Failed to get projects: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects")
async def create_project(
    request: ProjectCreateRequest,
    user_id: str = Depends(get_current_user),
    project_repo: ProjectRepository = Depends(get_project_repository)
) -> DashboardResponse:
    """Create a new project."""
    try:
        project = Project(
            id="",  # Will be generated by database
            name=request.name,
            full_name=request.full_name,
            description=request.description,
            url=request.url,
            default_branch=request.default_branch,
            language=request.language,
            status=ProjectStatus.ACTIVE
        )
        
        project_id = await project_repo.create_project(project)
        if not project_id:
            raise HTTPException(status_code=500, detail="Failed to create project")
        
        return DashboardResponse(
            success=True,
            message="Project created successfully",
            data={"project_id": project_id}
        )
    except Exception as e:
        logger.error(f"Failed to create project: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/pin")
async def pin_project(
    request: ProjectPinRequest,
    user_id: str = Depends(get_current_user),
    project_repo: ProjectRepository = Depends(get_project_repository)
) -> DashboardResponse:
    """Pin a project to the dashboard."""
    try:
        project_pin = ProjectPin(
            id="",  # Will be generated by database
            project_id=request.project_id,
            user_id=user_id,
            position=request.position,
            flow_status=FlowStatus.OFF
        )
        
        success = await project_repo.pin_project(project_pin)
        if not success:
            raise HTTPException(status_code=500, detail="Failed to pin project")
        
        return DashboardResponse(
            success=True,
            message="Project pinned successfully"
        )
    except Exception as e:
        logger.error(f"Failed to pin project: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/github")
async def get_github_repositories(
    user_id: str = Depends(get_current_user)
) -> DashboardResponse:
    """Get all GitHub repositories for the current user."""
    try:
        github_manager = GitHubProjectManager()
        repositories = await github_manager.get_user_repositories()
        
        return DashboardResponse(
            success=True,
            message=f"Retrieved {len(repositories)} repositories",
            data={"repositories": repositories}
        )
    except Exception as e:
        logger.error(f"Failed to get GitHub repositories: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/plans")
async def create_workflow_plan(
    project_id: str,
    request: WorkflowPlanRequest,
    background_tasks: BackgroundTasks,
    user_id: str = Depends(get_current_user),
    workflow_repo: WorkflowRepository = Depends(get_workflow_repository)
) -> DashboardResponse:
    """Create a new workflow plan for a project."""
    try:
        # Generate plan using Codegen SDK
        codegen_generator = CodegenPlanGenerator()
        generated_plan = await codegen_generator.generate_plan(
            project_id=project_id,
            requirements=request.requirements,
            title=request.title,
            description=request.description
        )
        
        workflow_plan = WorkflowPlan(
            id="",  # Will be generated by database
            project_id=project_id,
            title=request.title,
            description=request.description,
            requirements=request.requirements,
            generated_plan=generated_plan,
            created_by=user_id
        )
        
        plan_id = await workflow_repo.create_plan(workflow_plan)
        if not plan_id:
            raise HTTPException(status_code=500, detail="Failed to create workflow plan")
        
        # Schedule background task to process the plan
        background_tasks.add_task(process_workflow_plan, plan_id)
        
        return DashboardResponse(
            success=True,
            message="Workflow plan created successfully",
            data={"plan_id": plan_id, "generated_plan": generated_plan}
        )
    except Exception as e:
        logger.error(f"Failed to create workflow plan: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/plans")
async def get_workflow_plans(
    project_id: str,
    workflow_repo: WorkflowRepository = Depends(get_workflow_repository)
) -> DashboardResponse:
    """Get all workflow plans for a project."""
    try:
        plans = await workflow_repo.get_plans_by_project(project_id)
        
        # Convert to dict format for JSON response
        plans_data = []
        for plan in plans:
            plans_data.append({
                "id": plan.id,
                "project_id": plan.project_id,
                "title": plan.title,
                "description": plan.description,
                "requirements": plan.requirements,
                "generated_plan": plan.generated_plan,
                "tasks": plan.tasks,
                "estimated_duration": plan.estimated_duration,
                "complexity_score": plan.complexity_score,
                "status": plan.status.value,
                "created_at": plan.created_at.isoformat(),
                "updated_at": plan.updated_at.isoformat(),
                "created_by": plan.created_by,
                "metadata": plan.metadata
            })
        
        return DashboardResponse(
            success=True,
            message=f"Retrieved {len(plans)} workflow plans",
            data={"plans": plans_data}
        )
    except Exception as e:
        logger.error(f"Failed to get workflow plans: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/projects/{project_id}/plans/{plan_id}/start")
async def start_workflow(
    project_id: str,
    plan_id: str,
    background_tasks: BackgroundTasks,
    user_id: str = Depends(get_current_user)
) -> DashboardResponse:
    """Start workflow execution for a plan."""
    try:
        # Schedule background task to start workflow execution
        background_tasks.add_task(execute_workflow, plan_id, user_id)
        
        return DashboardResponse(
            success=True,
            message="Workflow execution started",
            data={"plan_id": plan_id, "status": "started"}
        )
    except Exception as e:
        logger.error(f"Failed to start workflow: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/projects/{project_id}/settings")
async def update_project_settings(
    project_id: str,
    request: SettingsUpdateRequest,
    user_id: str = Depends(get_current_user)
) -> DashboardResponse:
    """Update project settings."""
    try:
        # TODO: Implement project settings update
        # This would update the project_settings table with the new configuration
        
        return DashboardResponse(
            success=True,
            message="Project settings updated successfully"
        )
    except Exception as e:
        logger.error(f"Failed to update project settings: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/settings/environment")
async def update_environment_variables(
    request: EnvironmentVariablesRequest,
    user_id: str = Depends(get_current_user)
) -> DashboardResponse:
    """Update environment variables."""
    try:
        # Update environment variables (in a real implementation, these would be stored securely)
        updates = {}
        
        if request.github_token:
            os.environ["GITHUB_ACCESS_TOKEN"] = request.github_token
            updates["github_token"] = "updated"
        
        if request.linear_api_key:
            os.environ["LINEAR_ACCESS_TOKEN"] = request.linear_api_key
            updates["linear_api_key"] = "updated"
        
        if request.slack_token:
            os.environ["SLACK_BOT_TOKEN"] = request.slack_token
            updates["slack_token"] = "updated"
        
        if request.codegen_org_id:
            os.environ["CODEGEN_ORG_ID"] = request.codegen_org_id
            updates["codegen_org_id"] = "updated"
        
        if request.codegen_token:
            os.environ["CODEGEN_TOKEN"] = request.codegen_token
            updates["codegen_token"] = "updated"
        
        if request.postgresql_url:
            os.environ["POSTGRESQL_URL"] = request.postgresql_url
            updates["postgresql_url"] = "updated"
        
        return DashboardResponse(
            success=True,
            message="Environment variables updated successfully",
            data={"updates": updates}
        )
    except Exception as e:
        logger.error(f"Failed to update environment variables: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/projects/{project_id}/status")
async def get_project_status(
    project_id: str,
    user_id: str = Depends(get_current_user)
) -> DashboardResponse:
    """Get real-time status of a project."""
    try:
        # TODO: Implement real-time project status retrieval
        # This would gather status from various sources (GitHub, Linear, workflow execution, etc.)
        
        status_data = {
            "project_id": project_id,
            "flow_status": "off",
            "active_workflows": 0,
            "pending_prs": 0,
            "open_issues": 0,
            "last_activity": datetime.utcnow().isoformat(),
            "health_score": 85.5
        }
        
        return DashboardResponse(
            success=True,
            message="Project status retrieved successfully",
            data=status_data
        )
    except Exception as e:
        logger.error(f"Failed to get project status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Background task functions
async def process_workflow_plan(plan_id: str):
    """Background task to process a workflow plan."""
    try:
        logger.info(f"Processing workflow plan: {plan_id}")
        # TODO: Implement plan processing logic
        # This would break down the plan into tasks, create Linear issues, etc.
    except Exception as e:
        logger.error(f"Failed to process workflow plan {plan_id}: {e}")


async def execute_workflow(plan_id: str, user_id: str):
    """Background task to execute a workflow."""
    try:
        logger.info(f"Executing workflow for plan: {plan_id}")
        # TODO: Implement workflow execution logic
        # This would orchestrate the multi-layered workflow execution
    except Exception as e:
        logger.error(f"Failed to execute workflow for plan {plan_id}: {e}")


# Export the router
__all__ = ["router"]

